{
  "runner": "solana",
  "courseSlug": "intro-to-solana",
  "lessonSlug": "sysvar",
  "files": [
    {
      "path": "lib.rs",
      "content": "//! A program demonstrating the transfer of lamports\n#![forbid(unsafe_code)]\n\nmod entrypoint {\n    //! Program entrypoint\n\n    #![cfg(not(feature = \"no-entrypoint\"))]\n\n    use solana_program::{account_info::AccountInfo, entrypoint::ProgramResult, pubkey::Pubkey};\n\n    solana_program::entrypoint!(process_instruction);\n    fn process_instruction(\n        program_id: &Pubkey,\n        accounts: &[AccountInfo],\n        instruction_data: &[u8],\n    ) -> ProgramResult {\n        crate::processor::process_instruction(program_id, accounts, instruction_data)\n    }\n}\n\npub mod processor {\n    //! Program instruction processor\n\n    use solana_program::{\n        account_info::{next_account_info, AccountInfo},\n        entrypoint::ProgramResult,\n        msg,\n        pubkey::Pubkey,\n        sysvar::{clock::Clock, rent::Rent, Sysvar},\n    };\n\n    /// Instruction processor\n    pub fn process_instruction(\n        _program_id: &Pubkey,\n        accounts: &[AccountInfo],\n        _instruction_data: &[u8],\n    ) -> ProgramResult {\n        // Create in iterator to safety reference accounts in the slice\n        let account_info_iter = &mut accounts.iter();\n\n        // Get the clock sysvar via syscall\n        let clock_via_sysvar = Clock::get()?;\n        // Or deserialize the account into a clock struct\n        let clock_sysvar_info = next_account_info(account_info_iter)?;\n        let clock_via_account = Clock::from_account_info(clock_sysvar_info)?;\n        // Both produce the same sysvar\n        assert_eq!(clock_via_sysvar, clock_via_account);\n        // Note: `format!` can be very expensive, use cautiously\n        msg!(\"{:?}\", clock_via_sysvar);\n\n        // Get the rent sysvar via syscall\n        let rent_via_sysvar = Rent::get()?;\n        // Or deserialize the account into a rent struct\n        let rent_sysvar_info = next_account_info(account_info_iter)?;\n        let rent_via_account = Rent::from_account_info(rent_sysvar_info)?;\n        // Both produce the same sysvar\n        assert_eq!(rent_via_sysvar, rent_via_account);\n        // Can't print `exemption_threshold` because BPF does not support printing\n        // floats\n        msg!(\n        \"Rent: lamports_per_byte_year: {:?}, burn_percent: {:?}\",\n        rent_via_sysvar.lamports_per_byte_year,\n        rent_via_sysvar.burn_percent\n    );\n\n        Ok(())\n    }\n}\n"
    }
  ]
}
